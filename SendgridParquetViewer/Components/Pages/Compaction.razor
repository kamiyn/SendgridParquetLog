@page "/compaction"
@rendermode InteractiveServer
@using SendgridParquet.Shared
@using SendgridParquetViewer.Models
@using SendgridParquetViewer.Services
@using R3
@implements IDisposable
@inject ILogger<Compaction> Logger
@inject CompactionService CompactionService
@inject TimeProvider TimeProvider

<PageTitle>Compaction Management</PageTitle>

<FluentCard class="main-card">
    <FluentHeader>
        <FluentSpacer />
        <FluentLabel Typo="Typography.PageTitle">Compaction Management</FluentLabel>
        <FluentSpacer />
    </FluentHeader>

    <p>Manage Parquet file compaction processes for SendGrid webhook data.</p>

    <FluentGrid>
        <FluentGridItem xs="12" md="6">
            <FluentCard>
                <FluentHeader>
                    <FluentLabel Typo="Typography.Subject">Current Status</FluentLabel>
                </FluentHeader>
                
                @if (_isWaitingForLock)
                {
                    <FluentProgressRing />
                    <p>他インスタンスのロックの有効期限切れを待機しています...
                        @if (_lockExpiresAt.HasValue)
                        {
                            <br /><small>Lock ExpiresAt: @_lockExpiresAt.Value.ToString("s")</small>
                        }
                        @if (_runStatus != null)
                        {
                            <br /><small>Note: The status information below may be stale while waiting for the lock.</small>
                        }
                    </p>
                }
                @if (_runStatus != null)
                {
                    <p>
                        <div><strong>Start Time:</strong> @_runStatus.StartTime.ToString("s")</div>
                        @if (_runStatus.EndTime.HasValue)
                        {
                            <div><strong>End Time:</strong> @_runStatus.EndTime.Value.ToString("s")</div>
                            @if (_runStatus.AbnormalTermination)
                            {
                                <div><strong>Status:</strong> Abnormally Terminated</div>
                            }
                            else
                            {
                                <div><strong>Status:</strong>Completed</div>
                            }
                        }
                        else
                        {
                            <div><strong>Status:</strong>Running</div>
                            <div><strong>Completed Days:</strong> @_runStatus.DaysProgress()</div>
                            @if (_runStatus.CurrentDay.HasValue)
                            {
                                <br />
                                <strong>Current Day:</strong> @_runStatus.CurrentDay.Value
                                @if (_runStatus.CurrentDayTotalFiles.HasValue && _runStatus.CurrentDayProcessedFiles.HasValue)
                                {
                                    <br />
                                    <strong>Day Progress:</strong> @_runStatus.CurrentDayProgress()
                                }
                            }
                            <br />
                            <div><strong>Output Files Created:</strong> @_runStatus.OutputFilesCreated</div>
                            @if (!string.IsNullOrEmpty(_runStatus.LastOutputFile))
                            {
                                <div><strong>Last Output File:</strong> @_runStatus.LastOutputFile</div>
                            }
                            @if (!string.IsNullOrEmpty(_runStatus.LastProcessedFile))
                            {
                                <div><strong>Last Processed File:</strong> @_runStatus.LastProcessedFile</div>
                            }
                            <div><strong>Deleted Original Files:</strong> @_runStatus.DeletedOriginalFile</div>
                            <div><strong>Failed Original Files:</strong> @_runStatus.FailedOriginalFiles.Count</div>
                            <div><strong>Failed Output Files:</strong> @_runStatus.FailedOutputFiles.Count</div>
                            <div><small>Last Updated: @_runStatus.LastUpdated.ToString("s")</small></div>
                        }
                        <strong>Target Days:</strong> @_runStatus.TargetDays.Count<br />
                        <strong>Target Paths:</strong> @string.Join(", ", _runStatus.TargetPathPrefixes.Take(3))
                        @if (_runStatus.TargetPathPrefixes.Count > 3)
                        {
                            <text> and @(_runStatus.TargetPathPrefixes.Count - 3) more...</text>
                        }
                    </p>
                    <details>
						<summary>詳細 を表示</summary>
						<pre>
                            @GetRunStatusJson()
                        </pre>
                    </details>
                    @if (_runStatus.FailedOutputFiles.Count > 0 || _runStatus.FailedOriginalFiles.Count > 0)
                    {
                        <details>
							<summary>Failed Files を表示</summary>
							<summary>Failed files detail</summary>
                            @if (_runStatus.FailedOutputFiles.Count > 0)
                            {
                                <div><strong>Failed Output Files (@_runStatus.FailedOutputFiles.Count):</strong></div>
                                <pre>@string.Join(Environment.NewLine, _runStatus.FailedOutputFiles)</pre>
                            }
                            @if (_runStatus.FailedOriginalFiles.Count > 0)
                            {
                                <div><strong>Failed Original Files (@_runStatus.FailedOriginalFiles.Count):</strong></div>
                                <pre>@string.Join(Environment.NewLine, _runStatus.FailedOriginalFiles)</pre>
                            }
                        </details>
                    }
					@if (_runStatus.Errors.Any())
                    {
                        <details>
                            <summary>例外 を表示</summary>
                            @foreach (var error in _runStatus.Errors)
                            {
                                <pre>
                                 @(error.Message)
                            </pre>
                            }
                        </details>
                    }
                }
                else if (_isLoadingStatus)
                {
                    <FluentProgressRing />
                    <p>Loading status...</p>
                }
                else
                {
                    <p>No active compaction process found.</p>
                }

                <FluentButton Appearance="Appearance.Neutral" OnClick="RefreshStatus" Loading="_isLoadingStatus">
                    Refresh
                </FluentButton>
            </FluentCard>
        </FluentGridItem>

        <FluentGridItem xs="12" md="6">
            <FluentCard>
                <FluentHeader>
                    <FluentLabel Typo="Typography.Subject">Start New Compaction</FluentLabel>
                </FluentHeader>
                
                <p>Start a new compaction process. This will process all available non-compacted Parquet files.</p>

                <FluentButton Appearance="Appearance.Accent"
                             OnClick="StartCompaction"
                             Loading="_isStarting"
                             Disabled="@(_runStatus?.EndTime == null && _runStatus != null)">
                    Start Compaction
                </FluentButton>

                @if (_lockInfo != null)
                {
                    var now = TimeProvider.GetUtcNow();
                    var remaining = _lockInfo.ExpiresAt - now;
                    <div style="margin-top: 1em; padding: 0.5em; border: 1px solid var(--neutral-stroke-rest); border-radius: 4px;">
                        <div><strong>run.lock</strong></div>
                        <div><small>Owner: @_lockInfo.HostName (@_lockInfo.OwnerId)</small></div>
                        <div><small>AcquiredAt: @_lockInfo.AcquiredAt.ToJst().ToString("yyyy/MM/dd HH:mm:ss")</small></div>
                        <div><small>ExpiresAt: @_lockInfo.ExpiresAt.ToJst().ToString("yyyy/MM/dd HH:mm:ss")</small></div>
                        @if (remaining > TimeSpan.Zero)
                        {
                            <div><small><strong>残り時間: @FormatRemainingTime(remaining)</strong></small></div>
                        }
                        else
                        {
                            <div><small>Status: 期限切れ</small></div>
                        }
                    </div>
                }
            </FluentCard>
        </FluentGridItem>
    </FluentGrid>

    @if (!string.IsNullOrEmpty(_message))
    {
        <FluentMessageBar Intent="@_messageIntent" OnDismiss="() => _message = string.Empty">
            @_message
        </FluentMessageBar>
    }
</FluentCard>

@code {
	private static readonly TimeSpan LockExpiryClockSkewMargin = TimeSpan.FromSeconds(60);
	private RunStatus? _runStatus;
	private LockInfo? _lockInfo;
	private bool _isLoadingStatus;
	private bool _isStarting;
	private bool _isWaitingForLock;
	private DateTimeOffset? _lockExpiresAt;
	private string _message = string.Empty;
	private IDisposable? _runStatusSubjectSubscription;
	private PeriodicTimer? _lockCountdownTimer;
	private MessageIntent _messageIntent = MessageIntent.Info;
	readonly CancellationTokenSource _cts = new CancellationTokenSource();

	string GetRunStatusJson() => _runStatus != null
        ? JsonSerializer.Serialize(_runStatus, new JsonSerializerOptions { WriteIndented = true })
        : "{}";

	static string FormatRemainingTime(TimeSpan remaining)
	{
		if (remaining.TotalHours >= 1)
			return $"{(int)remaining.TotalHours}時間{remaining.Minutes:D2}分{remaining.Seconds:D2}秒";
		if (remaining.TotalMinutes >= 1)
			return $"{remaining.Minutes}分{remaining.Seconds:D2}秒";
		return $"{remaining.Seconds}秒";
	}

	protected override async Task OnInitializedAsync()
	{
		try
		{
			await RefreshStatus();
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Failed to refresh compaction status during initialization");
			ShowMessage("ステータスの取得に失敗しました。ロック状態を確認しています。", MessageIntent.Error);
		}

		// 自プロセスでスレッド進行中でなく、run.json が Running 状態の場合はロックの期限切れを確認する
		if (_runStatus != null && !_runStatus.EndTime.HasValue && !CompactionService.IsCompactionRunningLocally)
		{
			await WaitForAndCleanupStalledLockAsync();
		}

		_runStatusSubjectSubscription = CompactionService.RunStatusSubject
			.ObserveOnCurrentSynchronizationContext()
            .Subscribe(runStatus =>
            {
				// ObserveOnCurrentSynchronizationContext を使えば InvokeAsync() にしなくてよい
                _runStatus = runStatus;
                StateHasChanged();
			});
	}

	private async Task WaitForAndCleanupStalledLockAsync()
	{
		_isWaitingForLock = true;
		StateHasChanged();
		try
		{
			var lockInfo = await CompactionService.CleanupExpiredLockAsync(_cts.Token);
			if (lockInfo != null)
			{
				// ロックが有効期限内 → ExpiresAt まで待機
				// 他インスタンスとの時計のずれを考慮し余裕を持たせる
				var waitTime = lockInfo.ExpiresAt - TimeProvider.GetUtcNow() + LockExpiryClockSkewMargin;
				if (waitTime > TimeSpan.Zero)
				{
					_lockExpiresAt = lockInfo.ExpiresAt;
					StateHasChanged();
					// 管理画面のため同時ユーザー数は限定的であり、最大30分の待機中も SignalR 接続を維持する
					await Task.Delay(waitTime, _cts.Token);
				}
				else
				{
					// 時計のずれなどにより待機時間が 0 以下となった場合はログに記録して即時クリーンアップを試行する
					Logger.LogWarning(
						"Calculated wait time for lock cleanup is non-positive. WaitTime={WaitTime}, ExpiresAt={ExpiresAt}, Now={Now}",
						waitTime,
						lockInfo.ExpiresAt,
						TimeProvider.GetUtcNow());
				}

				// 待機後に再度クリーンアップ
				var secondLockInfo = await CompactionService.CleanupExpiredLockAsync(_cts.Token);
				if (secondLockInfo != null)
				{
					// 2回目に取得したロック情報が同じロックか、新しいロックかを判定する
					if (secondLockInfo.LockId == lockInfo.LockId)
					{
						// 同じロックが残っている → クリーンアップ失敗として扱う
						Logger.LogWarning("Lock cleanup after wait did not remove original lock. Lock info: {@LockInfo}", secondLockInfo);
						ShowMessage("ロックのクリーンアップに失敗しました。", MessageIntent.Error);
					}
					else
					{
						// 別のインスタンスが新しいロックを取得した可能性がある
						Logger.LogInformation(
							"A new lock was acquired after waiting for the previous lock to expire. Previous: {@PreviousLock}, New: {@NewLock}",
							lockInfo,
							secondLockInfo);
						ShowMessage("別のプロセスによって新しいロックが取得されました。しばらくしてから再試行してください。", MessageIntent.Warning);
					}
				}
			}

			await RefreshStatus();
		}
		catch (OperationCanceledException)
		{
			// ページ離脱時のキャンセル
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Error during stalled lock cleanup");
			ShowMessage("ロックのクリーンアップに失敗しました。", MessageIntent.Error);
		}
		finally
		{
			_isWaitingForLock = false;
			_lockExpiresAt = null;
			StateHasChanged();
		}
	}

	private async Task RefreshStatus()
	{
		_isLoadingStatus = true;
		try
		{
            _runStatus = await CompactionService.GetRunStatusAsync();
            _lockInfo = await CompactionService.GetLockInfoAsync();
            UpdateLockCountdownTimer();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error refreshing compaction status");
            ShowMessage("Error refreshing status", MessageIntent.Error);
        }
        finally
        {
            _isLoadingStatus = false;
        }
		StateHasChanged();
	}

	private void UpdateLockCountdownTimer()
	{
		var needsTimer = _lockInfo != null && _lockInfo.ExpiresAt > TimeProvider.GetUtcNow();
		if (needsTimer && _lockCountdownTimer == null)
		{
			_lockCountdownTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
			_ = RunLockCountdownAsync(_cts.Token);
		}
		else if (!needsTimer)
		{
			StopLockCountdownTimer();
		}
	}

	private async Task RunLockCountdownAsync(CancellationToken ct)
	{
		try
		{
			while (_lockCountdownTimer != null && await _lockCountdownTimer.WaitForNextTickAsync(ct))
			{
				if (_lockInfo == null || _lockInfo.ExpiresAt <= TimeProvider.GetUtcNow())
				{
					StopLockCountdownTimer();
					break;
				}
				await InvokeAsync(StateHasChanged);
			}
		}
		catch (OperationCanceledException)
		{
			// Cancellation is expected when the component is disposed or the countdown is stopped.
			Logger.LogDebug("Lock countdown timer was cancelled.");
		}
	}

	private void StopLockCountdownTimer()
	{
		_lockCountdownTimer?.Dispose();
		_lockCountdownTimer = null;
	}

    private async Task StartCompaction()
    {
        _isStarting = true;
        try
        {
            var result = await CompactionService.StartCompactionAsync(_cts.Token);
            if (result.StartTime != null)
            {
                ShowMessage($"Compaction started successfully at {result.StartTime}", MessageIntent.Success);
                await RefreshStatus();
            }
            else
            {
                ShowMessage($"Cannot start compaction: {result.Reason}", MessageIntent.Warning);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting compaction");
            ShowMessage("Error starting compaction", MessageIntent.Error);
        }
        finally
        {
            _isStarting = false;
        }
    }

    private void ShowMessage(string msg, MessageIntent intent)
    {
        _message = msg;
        _messageIntent = intent;
        StateHasChanged();
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
		_runStatusSubjectSubscription?.Dispose();
		StopLockCountdownTimer();
    }
}

