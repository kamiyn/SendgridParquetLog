@page "/compaction"
@rendermode InteractiveServer
@using SendgridParquetViewer.Models
@using SendgridParquetViewer.Services
@using R3
@implements IDisposable
@inject ILogger<Compaction> Logger
@inject CompactionService CompactionService

<PageTitle>Compaction Management</PageTitle>

<FluentCard class="main-card">
    <FluentHeader>
        <FluentSpacer />
        <FluentLabel Typo="Typography.PageTitle">Compaction Management</FluentLabel>
        <FluentSpacer />
    </FluentHeader>

    <p>Manage Parquet file compaction processes for SendGrid webhook data.</p>

    <FluentGrid>
        <FluentGridItem xs="12" md="6">
            <FluentCard>
                <FluentHeader>
                    <FluentLabel Typo="Typography.Subject">Current Status</FluentLabel>
                </FluentHeader>
                
                @if (_isWaitingForLock)
                {
                    <FluentProgressRing />
                    <p>他インスタンスのロックの有効期限切れを待機しています...
                        @if (_lockExpiresAt.HasValue)
                        {
                            <br /><small>Lock ExpiresAt: @_lockExpiresAt.Value.ToString("s")</small>
                        }
                    </p>
                }
                else if (_runStatus != null)
                {
                    <p>
                        <div><strong>Start Time:</strong> @_runStatus.StartTime.ToString("s")</div>
                        @if (_runStatus.EndTime.HasValue)
                        {
                            <div><strong>End Time:</strong> @_runStatus.EndTime.Value.ToString("s")</div>
                            @if (_runStatus.AbnormalTermination)
                            {
                                <div><strong>Status:</strong>Abnormally Terminated</div>
                            }
                            else
                            {
                                <div><strong>Status:</strong>Completed</div>
                            }
                        }
                        else
                        {
                            <div><strong>Status:</strong>Running</div>
                            <div><strong>Completed Days:</strong> @_runStatus.DaysProgress()</div>
                            @if (_runStatus.CurrentDay.HasValue)
                            {
                                <br />
                                <strong>Current Day:</strong> @_runStatus.CurrentDay.Value
                                @if (_runStatus.CurrentDayTotalFiles.HasValue && _runStatus.CurrentDayProcessedFiles.HasValue)
                                {
                                    <br />
                                    <strong>Day Progress:</strong> @_runStatus.CurrentDayProgress()
                                }
                            }
                            <br />
                            <div><strong>Output Files Created:</strong> @_runStatus.OutputFilesCreated</div>
                            @if (!string.IsNullOrEmpty(_runStatus.LastOutputFile))
                            {
                                <div><strong>Last Output File:</strong> @_runStatus.LastOutputFile</div>
                            }
                            @if (!string.IsNullOrEmpty(_runStatus.LastProcessedFile))
                            {
                                <div><strong>Last Processed File:</strong> @_runStatus.LastProcessedFile</div>
                            }
                            <div><strong>Deleted Original Files:</strong> @_runStatus.DeletedOriginalFile</div>
                            <div><strong>Failed Original Files:</strong> @_runStatus.FailedOriginalFiles.Count</div>
                            <div><strong>Failed Output Files:</strong> @_runStatus.FailedOutputFiles.Count</div>
                            <div><small>Last Updated: @_runStatus.LastUpdated.ToString("s")</small></div>
                        }
                        <strong>Target Days:</strong> @_runStatus.TargetDays.Count<br />
                        <strong>Target Paths:</strong> @string.Join(", ", _runStatus.TargetPathPrefixes.Take(3))
                        @if (_runStatus.TargetPathPrefixes.Count > 3)
                        {
                            <text> and @(_runStatus.TargetPathPrefixes.Count - 3) more...</text>
                        }
                    </p>
                    <details>
						<summary>詳細 を表示</summary>
						<pre>
                            @GetRunStatusJson()
                        </pre>
                    </details>
                    @if (_runStatus.FailedOutputFiles.Count > 0 || _runStatus.FailedOriginalFiles.Count > 0)
                    {
                        <details>
							<summary>Failed Files を表示</summary>
							<summary>Failed files detail</summary>
                            @if (_runStatus.FailedOutputFiles.Count > 0)
                            {
                                <div><strong>Failed Output Files (@_runStatus.FailedOutputFiles.Count):</strong></div>
                                <pre>@string.Join(Environment.NewLine, _runStatus.FailedOutputFiles)</pre>
                            }
                            @if (_runStatus.FailedOriginalFiles.Count > 0)
                            {
                                <div><strong>Failed Original Files (@_runStatus.FailedOriginalFiles.Count):</strong></div>
                                <pre>@string.Join(Environment.NewLine, _runStatus.FailedOriginalFiles)</pre>
                            }
                        </details>
                    }
					@if (_runStatus.Errors.Any())
                    {
                        <details>
                            <summary>例外 を表示</summary>
                            @foreach (var error in _runStatus.Errors)
                            {
                                <pre>
                                 @(error.Message)
                            </pre>
                            }
                        </details>
                    }
                }
                else if (_isLoadingStatus)
                {
                    <FluentProgressRing />
                    <p>Loading status...</p>
                }
                else
                {
                    <p>No active compaction process found.</p>
                }

                <FluentButton Appearance="Appearance.Neutral" OnClick="RefreshStatus" Loading="_isLoadingStatus">
                    Refresh
                </FluentButton>
            </FluentCard>
        </FluentGridItem>

        <FluentGridItem xs="12" md="6">
            <FluentCard>
                <FluentHeader>
                    <FluentLabel Typo="Typography.Subject">Start New Compaction</FluentLabel>
                </FluentHeader>
                
                <p>Start a new compaction process. This will process all available non-compacted Parquet files.</p>

                <FluentButton Appearance="Appearance.Accent" 
                             OnClick="StartCompaction" 
                             Loading="_isStarting"
                             Disabled="@(_runStatus?.EndTime == null && _runStatus != null)">
                    Start Compaction
                </FluentButton>
            </FluentCard>
        </FluentGridItem>
    </FluentGrid>

    @if (!string.IsNullOrEmpty(_message))
    {
        <FluentMessageBar Intent="@_messageIntent" OnDismiss="() => _message = string.Empty">
            @_message
        </FluentMessageBar>
    }
</FluentCard>

@code {
	private RunStatus? _runStatus;
	private bool _isLoadingStatus;
	private bool _isStarting;
	private bool _isWaitingForLock;
	private DateTimeOffset? _lockExpiresAt;
	private string _message = string.Empty;
	private IDisposable? _runStatusSubjectSubscription;
	private MessageIntent _messageIntent = MessageIntent.Info;
	readonly CancellationTokenSource _cts = new CancellationTokenSource();

	string GetRunStatusJson() => _runStatus != null
        ? JsonSerializer.Serialize(_runStatus, new JsonSerializerOptions { WriteIndented = true })
        : "{}";

	protected override async Task OnInitializedAsync()
	{
		try
		{
			await RefreshStatus();
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Failed to refresh compaction status during initialization");
			ShowMessage("ステータスの取得に失敗しました。ロック状態を確認しています。", MessageIntent.Error);
		}

		// 自プロセスでスレッド進行中でなく、run.json が Running 状態または取得できない場合はロックの期限切れを確認する
		if (!_runStatus?.EndTime.HasValue && !CompactionService.IsCompactionRunningLocally)
		{
			await WaitForAndCleanupStalledLockAsync();
		}

		_runStatusSubjectSubscription = CompactionService.RunStatusSubject
			.ObserveOnCurrentSynchronizationContext()
            .Subscribe(runStatus =>
            {
				// ObserveOnCurrentSynchronizationContext を使えば InvokeAsync() にしなくてよい
                _runStatus = runStatus;
                StateHasChanged();
			});
	}

	private async Task WaitForAndCleanupStalledLockAsync()
	{
		_isWaitingForLock = true;
		StateHasChanged();
		try
		{
			var lockInfo = await CompactionService.CleanupExpiredLockAsync(_cts.Token);
			if (lockInfo != null)
			{
				// ロックが有効期限内 → ExpiresAt まで待機
				var waitTime = lockInfo.ExpiresAt - DateTimeOffset.UtcNow;
				if (waitTime > TimeSpan.Zero)
				{
					_lockExpiresAt = lockInfo.ExpiresAt;
					StateHasChanged();
					// 管理画面のため同時ユーザー数は限定的であり、最大30分の待機中も SignalR 接続を維持する
					await Task.Delay(waitTime, _cts.Token);
				}

				// 待機後に再度クリーンアップ
				var secondLockInfo = await CompactionService.CleanupExpiredLockAsync(_cts.Token);
				if (secondLockInfo != null)
				{
					Logger.LogWarning("Lock cleanup after wait did not remove lock. Lock info: {@LockInfo}", secondLockInfo);
					ShowMessage("ロックのクリーンアップに失敗しました。", MessageIntent.Error);
				}
			}

			await RefreshStatus();
		}
		catch (OperationCanceledException)
		{
			// ページ離脱時のキャンセル
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Error during stalled lock cleanup");
			ShowMessage("ロックのクリーンアップに失敗しました。", MessageIntent.Error);
		}
		finally
		{
			_isWaitingForLock = false;
			_lockExpiresAt = null;
		}
	}

	private async Task RefreshStatus()
	{
		_isLoadingStatus = true;
		try
		{
            _runStatus = await CompactionService.GetRunStatusAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error refreshing compaction status");
            ShowMessage("Error refreshing status", MessageIntent.Error);
        }
        finally
        {
            _isLoadingStatus = false;
        }
		StateHasChanged();
	}

    private async Task StartCompaction()
    {
        _isStarting = true;
        try
        {
            var result = await CompactionService.StartCompactionAsync(_cts.Token);
            if (result.StartTime != null)
            {
                ShowMessage($"Compaction started successfully at {result.StartTime}", MessageIntent.Success);
                await RefreshStatus();
            }
            else
            {
                ShowMessage($"Cannot start compaction: {result.Reason}", MessageIntent.Warning);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting compaction");
            ShowMessage("Error starting compaction", MessageIntent.Error);
        }
        finally
        {
            _isStarting = false;
        }
    }

    private void ShowMessage(string msg, MessageIntent intent)
    {
        _message = msg;
        _messageIntent = intent;
        StateHasChanged();
    }

    public void Dispose()
    {
        _cts.Dispose();
		_runStatusSubjectSubscription?.Dispose();
    }
}

